import path from "node:path";
import fs from "fs-extra";
import { z } from "zod";
import type {
	AnyToolExecutor,
	ToolContext,
	ToolDefinition,
	ToolResult,
} from "./registry.js";

const PLAN_MODE_SCHEMA = z.object({
	plan: z.string().describe("The plan to write"),
	title: z.string().optional().describe("Plan title"),
});

const EXIT_PLAN_MODE_SCHEMA = z.object({
	approved: z.boolean().describe("Whether the plan is approved"),
	feedback: z.string().optional().describe("Feedback on the plan"),
});

let currentPlan: string | null = null;
let planModeActive = false;

export function isPlanMode(): boolean {
	return planModeActive;
}

export function setPlanMode(active: boolean): void {
	planModeActive = active;
	if (!active) {
		currentPlan = null;
	}
}

export function getCurrentPlan(): string | null {
	return currentPlan;
}

const READ_ONLY_TOOLS = [
	"read",
	"glob",
	"grep",
	"list_dir",
	"file_info",
	"web_fetch",
	"web_search",
	"code_search",
	"read_image",
	"read_pdf",
	"mcp_list_prompts",
	"mcp_get_prompt",
	"todo_write",
	"task",
	"write_plan",
	"exit_plan_mode",
];

export function isToolAllowedInPlanMode(toolName: string): boolean {
	if (!planModeActive) {
		return true;
	}
	return READ_ONLY_TOOLS.includes(toolName) || toolName.startsWith("mcp_");
}

async function writePlan(
	args: z.infer<typeof PLAN_MODE_SCHEMA>,
	ctx: ToolContext,
): Promise<ToolResult> {
	const { plan, title = "Implementation Plan" } = args;
	currentPlan = plan;

	const plansDir = path.join(ctx.cwd, ".tehuti", "plans");
	await fs.ensureDir(plansDir);

	const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, 19);
	const sanitizedTitle = title
		.toLowerCase()
		.replace(/[^a-z0-9]+/g, "-")
		.replace(/\.+/g, "")
		.slice(0, 50);
	const slug = sanitizedTitle || "plan";
	const planFile = path.join(plansDir, `${slug}-${timestamp}.md`);

	const content = `# ${title}

Created: ${new Date().toISOString()}
Working Directory: ${ctx.cwd}

---

${plan}

---
*This plan was generated by Tehuti CLI*
`;

	await fs.writeFile(planFile, content, "utf-8");

	return {
		success: true,
		output: `Plan written to: ${planFile}\n\n## Plan Preview\n\n${plan.slice(0, 1000)}${plan.length > 1000 ? "\n\n... (truncated)" : ""}`,
		metadata: {
			planFile,
			title,
		},
	};
}

async function exitPlanModeTool(
	args: z.infer<typeof EXIT_PLAN_MODE_SCHEMA>,
	_ctx: ToolContext,
): Promise<ToolResult> {
	const { approved, feedback } = args;

	if (approved) {
		setPlanMode(false);
		return {
			success: true,
			output:
				"Plan approved. Exiting plan mode. You can now proceed with implementation.",
			metadata: { approved: true },
		};
	} else {
		return {
			success: true,
			output: `Plan not approved. ${feedback ? `Feedback: ${feedback}` : "Please revise the plan."}\n\nStaying in plan mode for revisions.`,
			metadata: { approved: false, feedback },
		};
	}
}

export const planTools: ToolDefinition[] = [
	{
		name: "write_plan",
		description:
			"Write an implementation plan to a file. Use this during plan mode to document your approach before asking for approval.",
		parameters: PLAN_MODE_SCHEMA,
		execute: writePlan as AnyToolExecutor,
		category: "system",
		requiresPermission: false,
	},
	{
		name: "exit_plan_mode",
		description:
			"Exit plan mode with approval or feedback. After approval, destructive tools will be enabled.",
		parameters: EXIT_PLAN_MODE_SCHEMA,
		execute: exitPlanModeTool as AnyToolExecutor,
		category: "system",
		requiresPermission: false,
	},
];

export function getPlanModeSystemPrompt(): string {
	return `
## Plan Mode Active

You are in **Plan Mode** - a read-only exploration phase.

### Available Tools (Read-Only)
${READ_ONLY_TOOLS.map((t) => `- \`${t}\``).join("\n")}

### Unavailable Tools (Blocked)
- \`write\`, \`edit\`, \`delete_file\`, \`delete_dir\`, \`move\`, \`copy\`
- \`bash\`, \`start_background\`, \`kill_process\`
- Any MCP tools that modify state

### Your Task
1. Explore the codebase using read-only tools
2. Understand the requirements and constraints
3. Write a detailed plan using \`write_plan\`
4. Exit plan mode with \`exit_plan_mode\` when ready for approval

After approval, you will have full access to all tools for implementation.
`;
}
